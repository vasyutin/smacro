<!-- Этот файл сгенерирован автоматически. Не редактируйте его. -->

# Макропроцессор SMACRO

## Назначение и функции

SMACRO - простой макропроцессор, который предназначен для подготовки нескольких вариантов документации на основе одних исходных файлов. Область применения SMACRO не ограничивается разработкой документации, программа работает с любыми текстовыми файлами, в том числе с текстами программ.

Основные функции:
* включение в итоговые текстовые файлы блоков исходных текстовых файлов в зависимости от значений переменных, заданных в конфигурационных файлах;
* подстановка вместо переменных в исходных текстовых файлах их значений, заданных в конфигурационных файлах;
* автоматическая нумерация разделов, рисунков и пр. в тексте.

## Принцип работы

SMACRO копирует файлы из папки исходных файлов в папку, указанную как папка назначения. При этом при копировании SMACRO подставляет вместо переменных в исходных файлах их значения, указанные в конфигурационном файле с переменными. Кроме того в зависимости от истинности выражений, составленных из этих переменных, может копировать или не копировать фрагменты текста из исходных файлов в результирующие. Также при копировании SMACRO выполняет автоматическую нумерацию фрагментов текста, помеченных специальными тегами. 

При запуске SMACRO можно указать шаблоны или имена файлов, которые не обрабатываются при копировании (то есть копируются в папку назначения без изменений), и шаблоны или имена файлов, которые игнорируются программой (то есть не копируются в папку с результатами).

## Использование

```
smacro  -s <папка исходных файлов>
        -d <папка в которую записывается результат обработки> 
        -v <файл с переменными>
        [-e <шаблоны файлов, которые не обрабатываются> ...] 
        [-i <шаблоны файлов, которые игнорируются> ...] 
        [-o <файл, в котором перечислены файлы в том порядке, в котором они обрабатываются>] 
        [-@h] [--version] 
где:

  -s <папка исходных файлов>,  --source <папка исходных файлов>
     (обязательный параметр) Имя папки, содержащей файлы для обработки.
	  
  -d <папка с результатом обработки>,  --destination <папка с результатом обработки>
     (обязательный параметр) Имя папки, в которую записывается результат обработки.
	  
  -v <файл с переменными>,  --variables <файл с переменными>
     (обязательный параметр) Имя файла, содержащего значения переменных, которые 
     используются при обработке.

  -e <шаблоны файлов, которые не обрабатываются>,  
  --exclude <шаблоны файлов, которые не обрабатываются>
     (можно использовать несколько раз) Шаблоны или имена файлов, которые не обрабатываются 
     при копировании, то есть копируются без изменений в папку с результатами обработки.

  -i <шаблоны файлов, которые игнорируются>,  
  --ignore <шаблоны файлов, которые игнорируются>
     (можно использовать несколько раз) Шаблоны или имена файлов, которые которые 
     игнорируются программой, то есть не копируются в папку с результатами.

  -o <имя файла со списком файлов в порядке обработки>,
  --order <имя файла со списком файлов в порядке обработки>
     Имя файла, в котором перечислены исходные файлы в том порядке, в котором они 
     будут обрабатываться. Может потребоваться для правильной автонумерации 
     фрагментов текста.

   -@,  --at-prefixed
     Использовать символ '@' вместо '#' в директивах. То есть вместо директив 
     #//, #if, #elif, #else, #endif and #include использовать директивы 
     читаемыми управляющие конструкции языка SMACRO в файлах, в которых часто
     используется символ '#', например, в файлах на языке Markdown. Задание
     этого ключа влияет на все исходные файлы.

   --,  --ignore_rest
     Игнорировать аргументы после этого флага.

   --version
     Показывает версию программы и завершает её работу.

   -h,  --help
     Показывает информацию об использовании программы и завершает её работу.
```
## Файл переменных

Значения переменных, которые используются в процессе обработки текста, задаются в файле, имя которого передается как параметр командной строки. Каждое значение переменной задается в отдельной строке с помощью конструкции
```
имя_переменной=значение
```
где имя переменной - это последовательность строчных и заглавных латинских букв, цифр и знаков подчеркивания. Имя переменной должно начинаться с буквы или знака подчеркивания. Значение - это последовательность любых символов до конца строки (пробелы в конце строки игнорируются). Например,
```
LANGUAGE=Italiano
ProgramDescription=SMACRO is a simple macro processor that is designed...
_div01=<br>
```
Пустое значение задается строкой с именем переменной, например
```
VERSION_FOR_WEB
VERSION_FOR_PRINT
```
В файле переменных пустые строки и строки, начинающиеся с символа #, игнорируются.

## Директивы обработки

### Директива подстановки значения переменной

Конструкция вида
```
${имя_переменной}
```
заменяется в тексте на значение указанной переменной. Если такая переменная не определена в файле переменных, то выполнение программы завершится с сообщением об ошибке.

### Директивы управления обработкой

Язык SMACRO поддерживает несколько директив, управляющих тем, какие фрагменты файла включаются в его результирующую версию. Директивы должны находиться в начале строки, перед ними могут быть пробелы и знаки табуляции, но не должно быть других символов. Строки с директивами не копируются в результирующую версию файла.

**#//** - директива комментария. Строка, начинающаяся с этого оператора, игнорируется.

**#if**, **#elif**, **#else**, **#endif** - директивы условного оператора. Выполняют ту же роль, что и эти же директивы препроцессора в языке C/C++. В условиях могут использоваться выражения, которые проверяют, определены ли переменные, а также проверяют их значения. Блоки текста, для которых условия выполняются, переписываются в итоговые файлы. Пример задания условного оператора:
```
#if (defined(VAR1) && !defined(VAR2)) || Language == "Slovenščina"
	Besedilo na slovenskem
#elif Language == "Italiano"
   Un testo in italiano
#else
	Text in English
#endif
```

**#include** - директива включения файла. Вместо строки с этой директивой подставляется содержимое указанного в ней файла. Имя включаемого файла задается в квадратных скобках также, как в макропроцессоре C/C++. Например,

```
#include<./include/some-file.txt>
```
Для удобства при указании имени файла можно использовать встроенную переменную ${SMACRO_ROOT}, которая содержит путь к папке с исходными файлами.

```
#include<${SMACRO_ROOT}/include/file.inc>
```

Если при запуске программы указать ключ `-@` или `--at-prefixed`, то вместо директив #//, #if, #elif, #else, #endif и #include надо будет использовать директивы @//, @if, @elif, @else, @endif и @include. Это позволяет сделать более читаемыми управляющие конструкции языка SMACRO в файлах, в которых часто используется символ `#`, например, в файлах на языке Markdown. Задание этого ключа влияет на все исходные файлы при обработке.

### Выражения в условных директивах

Выражения в директивах **#if** и **#elif** строятся по правилам, принятым для языков C и C++. Они могут включать в себя операторы и скобки, управляющие порядком вычисления выражений. Можно использовать следующие операторы:

* **defined(имя_переменной)** - оператор проверки того, определена ли переменная в файле переменных. Возвращает true, если переменная определена и false в противном случае. Пример использования:
```
#if defined(VERSION) && defined(FOR_PRINT)
	...
#endif
```
* операторы сравнения **==** (равно), **!=** (не равно), **>** (больше), **>=** (больше или равно), **<** (меньше) и **<=** (меньше или равно) выполняют лексикографическое сравнение значений переменных или строковых констант. Строковые константы заключаются в двойные кавычки. Операторы возвращают true при истинности условия, или false при его ложности. Примеры использования операторов сравнения:
```
#if (VERSION > "1" && Language == "English") || Language == "Italiano"
   #if TARGET == "HTML"
	   <hr>
	#else
	   ------------
	#endif
#endif
```
* оператор логического И **&&** возвращает true при истинности обоих операндов. Пример использования:
```
#if (VERSION > "1" && Language == "English") && defined(PRINT_VERSION)
   ...
#endif
```
* оператор логического ИЛИ **||** возвращает true при истинности хотя бы одного из операндов. Пример использования:
```
#if VERSION > "1" || Language == "English" || defined(PRINT_VERSION)
   ...
#endif
```
* оператор отрицания **!** инвертирует значение находящегося за ним выражения. Пример использования:
```
#if !(VERSION > "1" || Language == "English") || !defined(PRINT_VERSION)
   ...
#endif
```
Выражение, которое не умещается на одной строке, может быть перенесено на следующую строку если указать символ `\` последним в строке, например
```
#if !(VERSION > "1" || Language == "English") || \
   !defined(PRINT_VERSION)
   ...
#endif
```

### Директивы для автоматической нумерации

В текстах, в которых необходимо автоматически нумеровать части, разделы, рисунки и пр. используются директивы **$number** и **$ref**. Директива **$number** заменяется на увеличенное на единицу значение заданного счетчика. Она записывается в тексте следующим образом
```
$number{ имя_номера | имя_счетчика }
```
где `имя_номера` - строка, которая позволяет ссылаться на полученное в этом месте текста значение счетчика в директиве **$ref** в других частях текста; `имя_счетчика` - счетчик, значение которого увеличивается при вставке номера вместо директивы **$number**. Имена номера и счетчика представляют собой текстовые строки без пробелов и знаков препинания. Например, следующие директивы
```
$number{number_intro | chapters}
$number{number_mainpart | chapters}
$number{number_figure_structure | figures}
$number{number_figure_streams | figures}
$number{number_conclusion | chapters}
```
будут преобразованы в такой текст
```
1
2
1
2
3
```
Для ссылки в тексте на номер, вставленный директивой **$number**, используется директива **$ref**. Записывается она следующим образом
```
$ref{ имя_номера }
``` 
где `имя_номера` - имя номера, на который ссылается директива. Например текст
```
See [$ref{Susanto19}, $ref{Amalia20}].

References
$number{Amalia20|References}. Amalia, C.F. Title...
$number{Susanto19|References}. Susanto, D.A. Title...
```
будет преобразован в текст
```
See [2, 1].

References
1. Amalia, C.F. Title...
2. Susanto, D.A. Title...
```
При автоматической генерации номеров в текстах, состоящих из нескольких отдельных файлов, важен порядок обработки файлов. Он может быть задан в командной строке при запуске программы опцией `-o` (`--order`), после которой следует имя файла со списком файлов в порядке обработки. В этом файле каждое имя файла задается на отдельной строке. Также можно использовать способ, когда все требуемые файлы включаются в один главный с помощью директив **#include**. В этом случае порядок обработки файлов определяется порядком директив **#include**.

### Директивы для именования фрагментов текста

Иногда необходимо вставить в текст строку, которая появляется в тексте в другом месте. Это может потребоваться, чтобы не дублировать текст, а также, чтобы при изменении текста в одном месте, он автоматически изменялся в другом. 

Для обозначения текста, который будет скопирован в другое место, используется директива **$name**. Формат ее записи следующий
```
$name{имя_текста | строка}
```
где `имя_текста` - уникальное имя, которое позволяет вставлять строку в других частях текста с помощью директивы $named; *строка* - последовательность символов. Для вставки в текст строки из директивы **$name** используется директива **$named**, для которой указывается имя строки, которую нужно вставить. Например, текст
```
1. $name{Chapter1 | Introduction}
...
In chapter <b>$named{Chapter1}</b>...
```
будет преобразован в текст
```
1. Introduction
...
In chapter <b>Introduction</b>...
```

### Примеры

С примерами использования директив можно ознакомиться в примерах, которые находятся в файлах с каталоге `/example` репозитория.

## Сборка и установка программы

### Linux

Для установки SMACRO под Linux необходимо выполнить сборку выполняемого файла из исходных текстов. Склонируйте репозиторий или загрузите архив с исходными текстами со страницы релизов (https://github.com/vasyutin/smacro/releases) и распакуйте его. Затем перейдите в каталог `/projects/gcc` и запустите команды

```sh
make
sudo make install
```

### Windows

Исполняемый файл программы может быть загружен со страницы релизов https://github.com/vasyutin/smacro/releases. Файл находится в ZIP-архиве. Извлеките исполняемый файл из архива и запишите его в папку, имя которой находится в списке в переменной окружения PATH. Это позволит запускать его из командной строки.

**Сборка исполняемого файла с помощью MinGW**

Склонируйте репозиторий или загрузите архив с исходными текстами со страницы релизов (https://github.com/vasyutin/smacro/releases) и распакуйте его. Затем перейдите в каталог `/projects/gcc` и запустите команду

```sh
mingw32-make
```
Результат компиляции находится в папке `/build/release`. Скопируйте файл `smacro.exe` в папку, имя которой находится в списке в переменной окружения `PATH`.

**Сборка исполняемого файла с помощью Visual Studio**

Склонируйте репозиторий или загрузите архив с исходными текстами со страницы релизов (https://github.com/vasyutin/smacro/releases) и распакуйте его. Откройте сольюшн `/projects/vs2022/smacro.sln` в среде Visual Studio. Выберите конфигурацию `Release` и запустите процесс сборки. Результат компиляции будет находиться в папке `/build/x64/Release`. Скопируйте файл `smacro.exe` в папку, имя которой находится в списке в переменной окружения `PATH`.


## Лицензия

GNU GPL Version 3

## Автор

Sergey Vasyutin (sergey [at] vasyut.in)
